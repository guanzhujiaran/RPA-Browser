<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC ICE Candidate æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .sidebar {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: fit-content;
        }
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .controls input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
            min-width: 120px;
        }
        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .video-container {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        video {
            width: 100%;
            height: auto;
            display: block;
            background: #000;
        }
        .video-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            text-align: center;
        }
        .video-placeholder svg {
            width: 64px;
            height: 64px;
            margin-bottom: 10px;
            opacity: 0.5;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            background: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
        }
        .status.connected { background: #d4edda; border-color: #c3e6cb; }
        .status.disconnected { background: #f8d7da; border-color: #f5c6cb; }
        .status.connecting { background: #fff3cd; border-color: #ffeaa7; }
        .header {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0;
            font-size: 20px;
            color: #333;
        }
        .connection-info {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
        }
        .connection-info strong {
            display: inline-block;
            min-width: 80px;
        }
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="header">
                <h1>ğŸ¥ WebRTC å®æ—¶è§†é¢‘æµ</h1>
                <div class="connection-info">
                    <div><strong>æµè§ˆå™¨ID:</strong> <span id="infoBrowserId">-</span></div>
                    <div><strong>ç”¨æˆ·ID:</strong> <span id="infoMid">-</span></div>
                    <div><strong>è¿æ¥çŠ¶æ€:</strong> <span id="infoConnectionStatus">æœªè¿æ¥</span></div>
                </div>
            </div>

            <div class="video-container">
                <div class="video-placeholder" id="videoPlaceholder">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                    <div>ç‚¹å‡»"è¿æ¥è§†é¢‘æµ"å¼€å§‹è§‚çœ‹</div>
                </div>
                <video id="video" autoplay playsinline muted></video>
            </div>
        </div>

        <div class="sidebar">
            <div class="controls">
                <input type="number" id="browserId" placeholder="æµè§ˆå™¨ID" value="130734684681277440">
                <input type="text" id="mid" placeholder="ç”¨æˆ·ID" value="38">
            </div>
            <div class="controls">
                <button onclick="connectWebRTC()" id="connectBtn" style="flex: 2;">è¿æ¥è§†é¢‘æµ</button>
                <button onclick="disconnectWebRTC()" id="disconnectBtn" disabled style="flex: 1;">æ–­å¼€</button>
            </div>
            <div class="controls">
                <button onclick="getStatus()" style="flex: 1;">çŠ¶æ€</button>
                <button onclick="clearLog()" style="flex: 1;">æ¸…é™¤</button>
            </div>
            <div class="status" id="status">ç­‰å¾…è¿æ¥...</div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000/api/v1/rpa/browser_live_control';
        let peerConnection = null;
        let isConnected = false;
        let candidateCount = 0;

        function log(message, type = 'info') {
            const statusElement = document.getElementById('status');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = {
                'info': 'â„¹ï¸',
                'success': 'âœ…',
                'error': 'âŒ',
                'warn': 'âš ï¸',
                'debug': 'ğŸ”'
            }[type] || 'â„¹ï¸';

            statusElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            statusElement.scrollTop = statusElement.scrollHeight;

            // æ›´æ–°è¿æ¥ä¿¡æ¯
            updateConnectionInfo();

            // åŒæ—¶è¾“å‡ºåˆ°æµè§ˆå™¨æ§åˆ¶å°
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function updateConnectionInfo() {
            document.getElementById('infoBrowserId').textContent = document.getElementById('browserId').value || '-';
            document.getElementById('infoMid').textContent = document.getElementById('mid').value || '-';
            document.getElementById('infoConnectionStatus').textContent = isConnected ? 'å·²è¿æ¥' : (peerConnection ? 'è¿æ¥ä¸­...' : 'æœªè¿æ¥');
            document.getElementById('infoConnectionStatus').style.color = isConnected ? '#28a745' : (peerConnection ? '#ffc107' : '#6c757d');
        }

        function showVideoStream() {
            document.getElementById('videoPlaceholder').style.display = 'none';
        }

        function hideVideoStream() {
            document.getElementById('videoPlaceholder').style.display = 'block';
        }

        function clearLog() {
            document.getElementById('status').textContent = '';
        }

        async function makeRequest(url, options = {}) {
            try {
                const response = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        'x-bili-mid': document.getElementById('mid').value,
                        ...options.headers,
                        "Access-Control-Allow-Origin": "*"
                    },
                    ...options
                });

                if (!response.ok) {
                    // å°è¯•è¯»å–é”™è¯¯è¯¦æƒ…
                    const errorText = await response.text();
                    console.error('Response error details:', errorText);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                return await response.json();
            } catch (error) {
                console.error('Request failed:', error);
                throw error;
            }
        }

        async function connectWebRTC() {
            const browserId = document.getElementById('browserId').value;
            const mid = document.getElementById('mid').value;

            if (!browserId || !mid) {
                alert('è¯·è¾“å…¥æµè§ˆå™¨IDå’Œç”¨æˆ·ID');
                return;
            }

            clearLog();
            candidateCount = 0;
            log(`å¼€å§‹ WebRTC è¿æ¥ï¼Œbrowser_id: ${browserId}`, 'info');

            try {
                // 1. åˆ›å»º WebRTC offer
                log('è¯·æ±‚åç«¯åˆ›å»º WebRTC offer...', 'info');
                const offerResponse = await makeRequest(`${API_BASE}/webrtc/offer`, {
                    method: 'POST',
                    body: JSON.stringify({ browser_id: String(browserId) })  // ğŸ”§ ç¡®ä¿å‘é€å­—ç¬¦ä¸²ç±»å‹
                });

                if (offerResponse.code !== 0) {
                    throw new Error(`åˆ›å»º offer å¤±è´¥: ${offerResponse.msg}`);
                }

                const offer = offerResponse.data;
                log(`æ”¶åˆ°æœåŠ¡å™¨ offerï¼ŒSDP é•¿åº¦: ${offer.sdp.length}`, 'success');

                // 2. åˆ›å»ºæœ¬åœ° PeerConnection
                log('åˆ›å»ºæœ¬åœ° RTCPeerConnection...', 'info');
                peerConnection = new RTCPeerConnection({
                    iceServers: []  // å±€åŸŸç½‘ç¯å¢ƒä¸éœ€è¦ STUN
                });

                // 3. è®¾ç½®è¿œç¨‹è§†é¢‘æµ
                peerConnection.ontrack = (event) => {
                    const video = document.getElementById('video');
                    video.srcObject = event.streams[0];
                    showVideoStream();
                    log('âœ…âœ…âœ… æ¥æ”¶åˆ°è¿œç¨‹è§†é¢‘æµï¼', 'success');
                };

                // ğŸ”¥ å…³é”®: ç›‘å¬ ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        candidateCount++;
                        const candidate = event.candidate;

                        log(`âš¡ æ”¶é›†åˆ° ICE candidate #${candidateCount}`, 'debug');
                        log(`   - candidate: ${candidate.candidate.substring(0, 80)}...`, 'debug');
                        log(`   - sdpMid: ${candidate.sdpMid}, sdpMLineIndex: ${candidate.sdpMLineIndex}`, 'debug');

                        // å‘é€åˆ°åç«¯
                        makeRequest(`${API_BASE}/webrtc/ice-candidate`, {
                            method: 'POST',
                            body: JSON.stringify({
                                browser_id: String(browserId),  // ğŸ”§ ç¡®ä¿å‘é€å­—ç¬¦ä¸²ç±»å‹
                                candidate: {
                                    candidate: candidate.candidate,
                                    sdpMid: candidate.sdpMid,
                                    sdpMLineIndex: candidate.sdpMLineIndex
                                }
                            })
                        }).then(response => {
                            if (response.code === 0) {
                                log(`   âœ… ICE candidate #${candidateCount} å‘é€æˆåŠŸ`, 'success');
                            } else {
                                log(`   âŒ ICE candidate #${candidateCount} å‘é€å¤±è´¥: ${response.msg}`, 'error');
                            }
                        }).catch(error => {
                            log(`   âŒ å‘é€ ICE candidate å¤±è´¥: ${error.message}`, 'error');
                        });
                    } else {
                        log(`ğŸ‰ ICE å€™é€‰æ”¶é›†å®Œæˆï¼Œæ€»æ•°: ${candidateCount}`, 'success');
                    }
                };

                // ç›‘å¬ ICE è¿æ¥çŠ¶æ€å˜åŒ–
                peerConnection.oniceconnectionstatechange = () => {
                    log(`ğŸ§Š ICE è¿æ¥çŠ¶æ€: ${peerConnection.iceConnectionState}`, peerConnection.iceConnectionState === 'connected' ? 'success' : 'info');

                    if (peerConnection.iceConnectionState === 'connected') {
                        isConnected = true;
                        log('ğŸ‰ WebRTC è§†é¢‘è¿æ¥å·²å»ºç«‹ï¼', 'success');
                        document.getElementById('connectBtn').disabled = true;
                        document.getElementById('disconnectBtn').disabled = false;
                    } else if (peerConnection.iceConnectionState === 'disconnected' || peerConnection.iceConnectionState === 'failed') {
                        isConnected = false;
                        log(`âŒ WebRTC è¿æ¥${peerConnection.iceConnectionState}`, 'error');
                        hideVideoStream();
                        document.getElementById('connectBtn').disabled = false;
                        document.getElementById('disconnectBtn').disabled = true;
                    }
                };

                // ç›‘å¬ä¿¡ä»¤çŠ¶æ€å˜åŒ–
                peerConnection.onsignalingstatechange = () => {
                    log(`ğŸ“¡ Signaling çŠ¶æ€: ${peerConnection.signalingState}`, 'info');
                };

                // 4. è®¾ç½®è¿œç¨‹æè¿°
                log('è®¾ç½®è¿œç¨‹ offer...', 'info');
                await peerConnection.setRemoteDescription({
                    type: offer.type,
                    sdp: offer.sdp
                });
                log('è¿œç¨‹ offer è®¾ç½®æˆåŠŸ', 'success');

                // 5. è·å–å¹¶æ·»åŠ æœåŠ¡ç«¯çš„ ICE candidates
                log('ğŸ“¥ è¯·æ±‚æœåŠ¡ç«¯çš„ ICE candidates...', 'info');
                const iceCandidatesResponse = await makeRequest(`${API_BASE}/webrtc/ice-candidates?browser_id=${browserId}`);
                if (iceCandidatesResponse.code === 0) {
                    const serverCandidates = iceCandidatesResponse.data.candidates;
                    log(`ğŸ“¦ æ”¶åˆ° ${serverCandidates.length} ä¸ªæœåŠ¡ç«¯ ICE candidates`, 'info');
                    log(`ğŸ“Š æœåŠ¡ç«¯ ICE gathering çŠ¶æ€: ${iceCandidatesResponse.data.ice_gathering_state}`, 'debug');

                    // æ·»åŠ æœåŠ¡ç«¯çš„ ICE candidates
                    for (const serverCandidate of serverCandidates) {
                        try {
                            await peerConnection.addIceCandidate(serverCandidate);
                            log(`âœ… æ·»åŠ æœåŠ¡ç«¯ ICE candidate: ${serverCandidate.candidate.substring(0, 50)}...`, 'debug');
                        } catch (error) {
                            log(`âŒ æ·»åŠ æœåŠ¡ç«¯ ICE candidate å¤±è´¥: ${error.message}`, 'error');
                        }
                    }
                    log(`âœ… å·²æ·»åŠ  ${serverCandidates.length} ä¸ªæœåŠ¡ç«¯ ICE candidates`, 'success');
                } else {
                    log(`âš ï¸ è·å–æœåŠ¡ç«¯ ICE candidates å¤±è´¥: ${iceCandidatesResponse.msg}`, 'warn');
                }

                // 6. åˆ›å»º answer
                log('åˆ›å»º WebRTC answer...', 'info');
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                log('æœ¬åœ° answer è®¾ç½®æˆåŠŸ', 'success');

                // ğŸ”§ å…³é”®ä¿®å¤ï¼šç­‰å¾… ICE gathering å®Œæˆ
                log(`ğŸ” å½“å‰ ICE gathering çŠ¶æ€: ${peerConnection.iceGatheringState}`, 'debug');

                if (peerConnection.iceGatheringState === 'new' || peerConnection.iceGatheringState === 'gathering') {
                    log('â³ ç­‰å¾… ICE gathering å®Œæˆ...', 'info');

                    // ç­‰å¾… ICE gathering å®Œæˆ
                    await new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            log(`ğŸ” ICE gathering çŠ¶æ€: ${peerConnection.iceGatheringState}, å·²æ”¶é›† ${candidateCount} ä¸ª candidates`, 'debug');
                            if (peerConnection.iceGatheringState === 'complete') {
                                clearInterval(checkInterval);
                                log('âœ… ICE gathering å®Œæˆ', 'success');
                                log(`ğŸ“Š æ€»å…±æ”¶é›†åˆ° ${candidateCount} ä¸ª ICE candidates`, 'info');
                                resolve();
                            }
                        }, 100);

                        // è¶…æ—¶ä¿æŠ¤ï¼ˆ15ç§’ï¼Œå¢åŠ è¶…æ—¶æ—¶é—´ï¼‰
                        setTimeout(() => {
                            clearInterval(checkInterval);
                            if (peerConnection.iceGatheringState !== 'complete') {
                                log(`âš ï¸ ICE gathering æœªåœ¨é¢„æœŸæ—¶é—´å†…å®Œæˆï¼ˆå½“å‰çŠ¶æ€: ${peerConnection.iceGatheringState}ï¼Œå·²æ”¶é›† ${candidateCount} ä¸ª candidatesï¼‰ï¼Œç»§ç»­å‘é€ answer`, 'warn');
                            }
                            resolve();
                        }, 15000);
                    });
                }

                // 6. å‘é€ answer åˆ°æœåŠ¡å™¨
                log('å‘é€ answer åˆ°æœåŠ¡å™¨...', 'info');
                const answerResponse = await makeRequest(`${API_BASE}/webrtc/answer`, {
                    method: 'POST',
                    body: JSON.stringify({
                        browser_id: String(browserId),  // ğŸ”§ ç¡®ä¿å‘é€å­—ç¬¦ä¸²ç±»å‹
                        sdp: answer.sdp
                    })
                });

                if (answerResponse.code !== 0) {
                    throw new Error(`è®¾ç½® answer å¤±è´¥: ${answerResponse.msg}`);
                }

                log('Answer å‘é€æˆåŠŸï¼Œç­‰å¾… ICE è¿æ¥å»ºç«‹...', 'success');

            } catch (error) {
                log(`WebRTC è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                console.error('WebRTC connection failed:', error);
                hideVideoStream();
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
            }
        }

        async function disconnectWebRTC() {
            const browserId = document.getElementById('browserId').value;

            try {
                log('å…³é—­ WebRTC è¿æ¥...', 'info');

                // é€šçŸ¥æœåŠ¡å™¨å…³é—­è¿æ¥
                await makeRequest(`${API_BASE}/webrtc/close`, {
                    method: 'POST',
                    body: JSON.stringify({ browser_id: String(browserId) })  // ğŸ”§ ç¡®ä¿å‘é€å­—ç¬¦ä¸²ç±»å‹
                });

                // å…³é—­æœ¬åœ°è¿æ¥
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }

                isConnected = false;
                log('WebRTC è¿æ¥å·²æ–­å¼€', 'success');
                document.getElementById('connectBtn').disabled = false;
                document.getElementById('disconnectBtn').disabled = true;
                hideVideoStream();

                // æ¸…é™¤è§†é¢‘æµ
                const video = document.getElementById('video');
                video.srcObject = null;

            } catch (error) {
                log(`æ–­å¼€è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async function getStatus() {
            const browserId = document.getElementById('browserId').value;

            try {
                log(`è·å–è¿æ¥çŠ¶æ€: browser_id=${browserId}`, 'info');
                const response = await makeRequest(`${API_BASE}/webrtc/status?browser_id=${browserId}`);

                if (response.code === 0) {
                    const status = response.data;
                    log(`è¿æ¥çŠ¶æ€: active=${status.active}, ICE=${status.ice_connection_state}, signaling=${status.signaling_state}`, 'info');
                } else {
                    log(`è·å–çŠ¶æ€å¤±è´¥: ${response.msg}`, 'error');
                }

            } catch (error) {
                log(`è·å–çŠ¶æ€å¤±è´¥: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
